"""
Module used internally by Pyto for importing C extension.
"""

if __platform__ is not iOS:
    raise ImportError("extensionsimporter can only be imported on iOS. C extensions can be loaded from anywhere on macOS. To check for platform, see the __platform__ global variable.")

import sys
import importlib
import traceback

if __host__ is not widget:
    from console import Alert
    from sharing import open_url
    import urllib.parse

def report_error(module, trace_back):
    """
    Sends an E-mail reporting error.
    
    Args:
        module: The module's that cannot be imported name.
        trace_back: Traceback as string.
    """

    alert = Alert.alertWithTitle(module, message="An error occurred while importing "+module+".\n\nDo you want to report error to the developer?")
    alert.addAction("Report")
    alert.addCancelAction("Cancel")

    if alert.show() == "Report":
        open_url("mailto://adri_labbe@hotmail.com?subject="+module+"%20Importing%20Error&body="+urllib.parse.quote(trace_back))

# MARK: - NumPy

class NumpyImporter(object):
    """
    Meta path for importing NumPy to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('numpy.core._multiarray_umath', 'numpy.fft.fftpack_lite', 'numpy.linalg._umath_linalg', 'numpy.linalg.lapack_lite', 'numpy.random.mtrand'):
            return self
        
        if fullname == 'numpy' and not self.__is_importing__:
            return self
        
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'numpy':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                mod = importlib.__import__(f)
                sys.modules[fullname] = mod
            
            if fullname != 'numpy' or __host__ is widget:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    pass
                except SystemExit:
                    pass
                except Exception as e:
                    print(e)
                    report_error('Numpy', traceback.format_exc())
                    raise
                finally:
                    self.__is_importing__ = False

            return mod
        
        return mod

# MARK: - Matplotlib

class MatplotlibImporter(object):
    """
    Meta path for importing Matplotlib to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('matplotlib.backends._backend_agg', 'matplotlib._path', 'matplotlib._image', 'matplotlib._png', 'matplotlib.ft2font', 'matplotlib._contour', 'matplotlib._qhull', 'matplotlib._tri', 'matplotlib.ttconv', 'matplotlib._cntr', 'matplotlib._delaunay'):
            return self
        
        if fullname == 'matplotlib' and not self.__is_importing__:
            return self
        
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'matplotlib':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                mod = importlib.__import__(f)
                sys.modules[fullname] = mod
            
            if fullname != 'matplotlib' or __host__ is widget:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    print(e)
                    report_error('Matplotlib', traceback.format_exc())
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        
        return mod

# MARK: - Pandas

class PandasImporter(object):
    """
    Meta path for importing Pandas to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'pandas' and not self.__is_importing__:
            return self
        
        if fullname in ('pandas._libs.writers', 'pandas.io.msgpack._packer', 'pandas.io.sas._sas', 'pandas._libs.hashtable', 'pandas._libs.reshape', 'pandas._libs.tslib', 'pandas._libs.interval', 'pandas._libs.missing', 'pandas._libs.ops', 'pandas.io.msgpack._unpacker', 'pandas._libs.hashing', 'pandas._libs.join', 'pandas._libs.sparse', 'pandas._libs.indexing', 'pandas._libs.parsers', 'pandas._libs.algos', 'pandas._libs.reduction', 'pandas._libs.testing', 'pandas._libs.properties', 'pandas._libs.internals', 'pandas._libs.window', 'pandas._libs.json', 'pandas._libs.index', 'pandas._libs.groupby', 'pandas._libs.skiplist', 'pandas._libs.lib', 'pandas.util._move', 'pandas._libs.tslibs.ccalendar', 'pandas._libs.tslibs.conversion', 'pandas._libs.tslibs.fields', 'pandas._libs.tslibs.nattype', 'pandas._libs.tslibs.timedeltas', 'pandas._libs.tslibs.frequencies', 'pandas._libs.tslibs.resolution', 'pandas._libs.tslibs.offsets', 'pandas._libs.tslibs.np_datetime', 'pandas._libs.tslibs.period', 'pandas._libs.tslibs.timezones', 'pandas._libs.tslibs.strptime', 'pandas._libs.tslibs.parsing', 'pandas._libs.tslibs.timestamps'):
            return self
        
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'pandas':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                mod = importlib.__import__(f)
                sys.modules[fullname] = mod
            
            if fullname != 'pandas' or __host__ is widget:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    print(e)
                    report_error('Pandas', traceback.format_exc())
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        
        return mod

# MARK: - LXML

class LXMLImporter(object):
    """
    Meta path for importing LXML to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'lxml' and not self.__is_importing__:
            return self
                
        if fullname in ('lxml._elementpath', 'lxml.builder', 'lxml.etree', 'lxml.clean', 'lxml.diff', 'lxml.objectifiy'):
            return self
        
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'lxml':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                mod = importlib.__import__(f)
                sys.modules[fullname] = mod
            
            if fullname != 'lxml' or __host__ is widget:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    print(e)
                    report_error('LXML', traceback.format_exc())
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        
        return mod

# MARK: - All

__all__ = ['NumpyImporter', 'MatplotlibImporter', 'PandasImporter', 'LXMLImporter']
