# -*- coding: utf-8 -*-
"""
This module gives access to the console.
"""

import ctypes
import PytoClasses
import mainthread
import importlib.util
import os
import sys
import traceback
import threading
import time

ignoredThreads = []
"""
All output and input request from these threads will be ignored.
"""

def __console__():
    return PytoClasses.ConsoleViewController.visible

def __clear__() -> None:
    __console__().textView.text = ""
    __console__().console = ""

def clear():
    """
    Clears the console.
    """
    mainthread.runSync(__clear__)

__script__ = None

def runScriptAtPath(path):
    """
    Run the script at given path catching exceptions.
    
    This function should only be used internally by Pyto.
    
    Args:
        path: The path of the script.
    """
    
    sys.argv = [path]
    for arg in PytoClasses.Python.shared.args:
        sys.argv.append(str(arg))
    
    def run() -> None:
        os.system = PytoClasses.Python.shared.system
        directory = os.path.expanduser(os.path.dirname(path))
        sys.path.insert(0, directory)
        try:
            global __script__
            spec = importlib.util.spec_from_file_location("__main__", path)
            __script__ = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(__script__)
            PytoClasses.Python.shared.values = [item for item in dir(__script__) if not item.startswith("__")]
        except SystemExit:
            pass
        except KeyboardInterrupt:
            pass
        except Exception as e:
            if not PytoClasses.__isMainApp__():
                print(traceback.format_exc())
                PytoClasses.Python.shared.fatalError(str(e))
            else:
                exc_type, exc_obj, exc_tb = sys.exc_info()
            
                extracts = traceback.extract_tb(sys.exc_info()[2])
                count = len(extracts)
            
                lineNumber = -1
            
                fileName = path
                for i, extract in enumerate(extracts):
                    if extract[0] == fileName:
                        lineNumber = extract[1]
                        break
                    count -= 1
            
                if (type(e) == SyntaxError): # The last word in a `SyntaxError` exception is the line number
                    lineNumber = [int(s) for s in (str(e)[:-1]).split() if s.isdigit()][-1]

                PytoClasses.Python.shared.errorType = exc_type.__name__
                PytoClasses.Python.shared.errorReason = str(e)
                PytoClasses.EditorViewController.visible.showErrorAtLine(lineNumber)

                print(traceback.format_exc(limit=-count))
            
            sys.path.remove(directory)

        if (PytoClasses.__isMainApp__()):
            PytoClasses.ReviewHelper.shared.launches = PytoClasses.ReviewHelper.shared.launches+1
            PytoClasses.ReviewHelper.shared.requestReview()
        PytoClasses.Python.shared.isScriptRunning = False
    
    thread = threading.Thread(target=run, args=())

    # Taken from https://gist.github.com/liuw/2407154
    NULL = 0
    def ctype_async_raise(thread_obj, exception):
        found = False
        target_tid = 0
        for tid, tobj in threading._active.items():
            if tobj is thread_obj:
                found = True
                target_tid = tid
                break

        if not found:
            raise ValueError("Invalid thread object")
    
        ret = ctypes.pythonapi.PyThreadState_SetAsyncExc(ctypes.c_long(target_tid), ctypes.py_object(exception))
        # ref: http://docs.python.org/c-api/init.html#PyThreadState_SetAsyncExc
        if ret == 0:
            raise ValueError("Invalid thread ID")
        elif ret > 1:
            # Huh? Why would we notify more than one threads?
            # Because we punch a hole into C level interpreter.
            # So it is better to clean up the mess.
            ctypes.pythonapi.PyThreadState_SetAsyncExc(target_tid, NULL)
            raise SystemError("PyThreadState_SetAsyncExc failed")
        
    def loop():
        while PytoClasses.Python.shared.isScriptRunning:
            time.sleep(0.25)
        ignoredThreads.append(thread)
        if thread.isAlive():
            ctype_async_raise(thread, KeyboardInterrupt)


    thread.start()
    loop()
    return __script__


# MARK: - I/O

__PyInputHelper__ = PytoClasses.PyInputHelper

def input(prompt="Input"):
    """
    Requests input with given prompt.
        
    Args:
        prompt: Text printed before the user's input without a newline.
    """
    
    __PyInputHelper__.userInput = None
    
    __PyInputHelper__.showAlertWithPrompt(prompt)
    
    while (__PyInputHelper__.userInput == None):
        
        if (threading.currentThread() in ignoredThreads):
            return ""
        
        continue
    
    userInput = __PyInputHelper__.userInput
    __PyInputHelper__.userInput = None
    return str(userInput)

__PyOutputHelper__ = PytoClasses.PyOutputHelper

def print(*objects, sep=None, end=None):
    """
    Prints to the Pyto console, not to the stdout. Works as the builtin `print` function but does not support printing to a custom file. Pyto catches by default the stdout and the stderr, so use the builtin function instead. This function is mainly for internal use.
    """
    if sep is None:
        sep = ' '
    if end is None:
        end = '\n'
    array = map(str, objects)
    __PyOutputHelper__.print(sep.join(array)+end)

# MARK: - Alerts

Alert = PytoClasses.Alert
"""
A class representing an alert.

Example:

    alert = Pyto.Alert.alertWithTitle("Hello", message="Hello World!")
    alert.addAction("Ok")
    alert.addCancel("Cancel")
    if (alert.show() == "Ok"):
        print("Good Bye!")
"""
