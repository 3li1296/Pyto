# -*- coding: utf-8 -*-
"""
This module gives access to the console.
"""

if __platform__ is macOS:
    raise ImportError("`console` module can only be imported on iOS. To check for platform, see the `__platform__` global variable.")

from rubicon.objc import *
from _asyncraise import ctype_async_raise
from _get_variables_hierarchy import get_variables_hierarchy
from code import interact
from pyto import *
from pyto import __isMainApp__
import mainthread
import importlib.util
import os
import sys
import traceback
import threading
import time
import _codecompletion
import stopit

__repl_code__ = {}

__continue_code_completion__ = True

__isREPLAskingForInput__ = False

def __repl_raw_input__(prompt=None):
    
    current_thread = threading.current_thread()
    
    ConsoleViewController.visible.suggestions = []
    ConsoleViewController.visible.completions = []
    ConsoleViewController.visible.reloadSuggestions()
    
    __isREPLAskingForInput__ = True
    Python.shared.isREPLAskingForInput = True
    
    def code_completion():
        
        prompt_ = ""
        
        while True:
            
            def continue_():
                return (not threading.current_thread() in ignoredThreads and not current_thread in ignoredThreads)
            
            if not continue_():
                break
            
            if __platform__ is iOS and prompt_ != str(ConsoleViewController.visible.prompt):
                prompt_ = str(ConsoleViewController.visible.prompt)
            
                code = ";\n"+__repl_code__[current_thread]+"\n"+prompt_+";"
            
                suggestions = []
                completions = []
                for key, value in _codecompletion.suggestionsForCode(code).items():
                    suggestions.append(key)
                    completions.append(value)
    
                if continue_():
                    ConsoleViewController.visible.completions = completions
                    ConsoleViewController.visible.suggestions = suggestions
                else:
                    break
            else:
                continue

    if not current_thread in __repl_code__:
        __repl_code__[current_thread] = "\n"

    code_completion_thread = None
    if __platform__ is iOS and ConsoleViewController.visible != None:
        code_completion_thread = threading.Thread(target=code_completion, args=())
        code_completion_thread.start()
    
    result = ""
    exc = None
    try:
        result = input(prompt)
    except Exception as e:
        exc = e

    __isREPLAskingForInput__ = False
    Python.shared.isREPLAskingForInput = False
    if __platform__ is iOS and ConsoleViewController.visible != None:
        ConsoleViewController.visible.suggestions = []
        ConsoleViewController.visible.completions = []
        ConsoleViewController.visible.reloadSuggestions

    if exc != None:
        raise exc

    if __platform__ is iOS and ConsoleViewController.visible != None:
        ignoredThreads.append(code_completion_thread)

    __repl_code__[current_thread] += "\n"+result

    return result

def __runREPL__():
    
    os.system = Python.shared.system
    
    sys.argv = ['']
        
    Python.shared.isScriptRunning = True
        
    interact(readfunc=__repl_raw_input__)

ignoredThreads = []
"""
All output and input request from these threads will be ignored.
"""

def __console__():
    if __platform__ is iOS:
        return ConsoleViewController.visible
    elif __platform__ is macOS:
        return EditorViewController
    else:
        return

def clear():
    """
    Clears the console.
    """
    
    if threading.current_thread() in ignoredThreads:
        return
    
    __console__().clear()

__script__ = None

__is_loop_running__ = False

__inspector_thread__ = None

def run_script(path, replMode=False):
    """
    Run the script at given path catching exceptions.
    
    This function should only be used internally by Pyto.
    
    Args:
        path: The path of the script.
        replMode: If set to `True`, errors will not be handled.
    """
    
    sys.argv = [path]
    for arg in Python.shared.args:
        if arg != "":
            sys.argv.append(str(arg))
    
    def run() -> None:
        
        Python.shared.isScriptRunning = True
        
        os.system = Python.shared.system
        directory = os.path.expanduser(os.path.dirname(path))
        os.chdir(directory)
        sys.path.insert(0, directory)
        try:
            global __script__
            spec = importlib.util.spec_from_file_location("__main__", path)
            __script__ = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(__script__)
            Python.shared.values = [item for item in dir(__script__) if not item.startswith("__")]
        except SystemExit:
            pass
        except KeyboardInterrupt:
            pass
        except Exception as e:
            if not __isMainApp__() or replMode:
                print(traceback.format_exc())
                if not replMode:
                    Python.shared.fatalError(str(e))
            else:
                exc_type, exc_obj, exc_tb = sys.exc_info()
            
                extracts = traceback.extract_tb(sys.exc_info()[2])
                count = len(extracts)
            
                lineNumber = -1
            
                fileName = path
                for i, extract in enumerate(extracts):
                    if extract[0] == fileName:
                        lineNumber = extract[1]
                        break
                    count -= 1
            
                if (type(e) == SyntaxError): # The last word in a `SyntaxError` exception is the line number
                    lineNumber = [int(s) for s in (str(e)[:-1]).split() if s.isdigit()][-1]

                Python.shared.errorType = exc_type.__name__
                Python.shared.errorReason = str(e)
                if __platform__ is iOS:
                    EditorSplitViewController.visible.editor.showErrorAtLine(lineNumber)
                else:
                    pass
                    #EditorViewController.showErrorAtLine(lineNumber)

                trace_back = traceback.format_exc(limit=-count)
                trace_back = trace_back.replace(str(DocumentBrowserViewController.iCloudContainerURL.path), "iCloud")
                trace_back = trace_back.replace(str(DocumentBrowserViewController.localContainerURL.path), "Documents")
                PyOutputHelper.printError(trace_back)
            
            sys.path.remove(directory)

        if (__isMainApp__() and __platform__ is iOS):
            ReviewHelper.shared.launches = ReviewHelper.shared.launches+1
            ReviewHelper.shared.requestReview()

        Python.shared.isScriptRunning = False
        Python.shared._isScriptRunning = False
    
    thread = threading.Thread(target=run, args=())
    
    def loop():
        
        while Python.shared._isScriptRunning:
            __is_loop_running__ = True
            
            updateInspector = True
            if updateInspector:
                if __platform__ is iOS and not ConsoleViewController.isMainLoopRunning:
                    try:
                        vars = get_variables_hierarchy(__script__)
                        if vars != ConsoleViewController.variables:
                            ConsoleViewController.variables = vars
                    except:
                        pass
                else:
                    updateInspector = False
            time.sleep(0.5)
            
        __is_loop_running__ = False
        
        if thread.isAlive():
            target_tid = 0
            for tid, tobj in threading._active.items():
                if tobj is thread:
                    found = True
                    target_tid = tid
                    break
            
            stopit.async_raise(target_tid, SystemExit)
            time.sleep(0.5)
        
        if thread.isAlive():
            Python.shared._isScriptRunning = True
            loop()

    Python.shared.isScriptRunning = True
    Python.shared._isScriptRunning = True
    
    '''global __inspector_thread__
    if __inspector_thread__ == None:
        __inspector_thread__ = threading.Thread(target=inspect, args=())
        __inspector_thread__.start()'''
    
    #loop_thread = threading.Thread(target=loop, args=())
    #loop_thread.start()
    
    thread.start()

    loop()

    sys.__stdout__.write("Execution finished\n")
    
    try:
        vars = get_variables_hierarchy(__script__)
        if __platform__ is iOS:
            if vars != ConsoleViewController.variables:
                ConsoleViewController.variables = vars
        elif __platform__ is macOS:
            if vars != EditorViewController.variables:
                EditorViewController.variables = vars
    except:
        pass
    
    Python.shared._isScriptRunning = False
    Python.shared.isScriptRunning = False

    return __script__

# MARK: - I/O

__PyInputHelper__ = PyInputHelper

def input(prompt=""):
    """
    Requests input with given prompt.
        
    Args:
        prompt: Text printed before the user's input without a newline.
    """
    
    NSBundle = ObjCClass("NSBundle")
    if NSBundle.mainBundle.bundlePath.pathExtension == "appex":
        return None
    
    if __platform__ is iOS:
        if not __isREPLAskingForInput__ and ConsoleViewController.visible != None:
            ConsoleViewController.visible.suggestions = []
            ConsoleViewController.visible.completions = []
    
    __PyInputHelper__.userInput = None
    
    __PyInputHelper__.showAlertWithPrompt(prompt)
    
    while __PyInputHelper__.userInput == None or threading.currentThread() in ignoredThreads:
        continue
    
    userInput = __PyInputHelper__.userInput
    __PyInputHelper__.userInput = None

    if str(userInput) == chr(3):
        raise KeyboardInterrupt
    
    return str(userInput)

__PyOutputHelper__ = PyOutputHelper

def print(*objects, sep=None, end=None):
    """
    Prints to the Pyto console, not to the stdout. Works as the builtin `print` function but does not support printing to a custom file. Pyto catches by default the stdout and the stderr, so use the builtin function instead. This function is mainly for internal use.
    """
    if sep is None:
        sep = ' '
    if end is None:
        end = '\n'
    array = map(str, objects)
    __PyOutputHelper__.print(sep.join(array)+end)

# MARK: - Alerts

if __host__ is not widget:

    Alert = Alert
    """
    A class representing an alert.

    Example:

        alert = console.Alert.alertWithTitle("Hello", message="Hello World!")
        alert.addAction("Ok")
        alert.addCancelAction("Cancel")
        if (alert.show() == "Ok"):
            print("Good Bye!")
    """

else:
    Alert = None

